# Copyright(C) Facebook, Inc. and its affiliates.
from fabric import task

from benchmark.local import LocalBench
from benchmark.logs import ParseError, LogParser
from benchmark.utils import Print
from benchmark.remote import Bench, BenchError
from benchmark.cloudlab_instance import CloudLabInstanceManager
from benchmark.cloudlab_remote import CloudLabBench

# Import AWS instance module only when needed (lazy import - CloudLab doesn't need it)
try:
    from benchmark.instance import InstanceManager
except ImportError:
    InstanceManager = None

# Import plot module only when needed (lazy import)
try:
    from benchmark.plot import Ploter, PlotError
except ImportError:
    Ploter = None
    PlotError = None


@task
def local(ctx, debug=True):
    ''' Run benchmarks on localhost '''
    bench_params = {
        'faults': 0,
        'nodes': 4,
        'workers': 1,
        'rate': 35000,
        'tx_size': 512,
        'duration': 90,
        'trigger_attack': True
    }
    node_params = {
        'header_size': 1_000,  # bytes
        'max_header_delay': 200,  # ms
        'gc_depth': 50,  # rounds
        'sync_retry_delay': 10_000,  # ms
        'sync_retry_nodes': 3,  # number of nodes
        'batch_size': 500_000,  # bytes
        'max_batch_delay': 200  # ms
    }
    try:
        ret = LocalBench(bench_params, node_params).run(debug)
        print(ret.result())
    except BenchError as e:
        Print.error(e)


@task
def create(ctx, nodes=2):
    ''' Create a testbed'''
    if InstanceManager is None:
        Print.error('InstanceManager is not available (boto3 may not be installed)')
        return
    try:
        InstanceManager.make().create_instances(nodes)
    except BenchError as e:
        Print.error(e)


@task
def destroy(ctx):
    ''' Destroy the testbed '''
    if InstanceManager is None:
        Print.error('InstanceManager is not available (boto3 may not be installed)')
        return
    try:
        InstanceManager.make().terminate_instances()
    except BenchError as e:
        Print.error(e)


@task
def start(ctx, max=2):
    ''' Start at most `max` machines per data center '''
    if InstanceManager is None:
        Print.error('InstanceManager is not available (boto3 may not be installed)')
        return
    try:
        InstanceManager.make().start_instances(max)
    except BenchError as e:
        Print.error(e)


@task
def stop(ctx):
    ''' Stop all machines '''
    if InstanceManager is None:
        Print.error('InstanceManager is not available (boto3 may not be installed)')
        return
    try:
        InstanceManager.make().stop_instances()
    except BenchError as e:
        Print.error(e)


@task
def info(ctx):
    ''' Display connect information about all the available machines '''
    if InstanceManager is None:
        Print.error('InstanceManager is not available (boto3 may not be installed)')
        return
    try:
        InstanceManager.make().print_info()
    except BenchError as e:
        Print.error(e)


@task
def install(ctx):
    ''' Install the codebase on all machines '''
    try:
        Bench(ctx).install()
    except BenchError as e:
        Print.error(e)


@task
def remote(ctx, debug=False):
    ''' Run benchmarks on AWS '''
    bench_params = {
        'faults': 0,
        'nodes': 10,
        'workers': 1,
        'collocate': True,
        'rate': 100_000,
        'tx_size': 512,
        'duration': 20,
        'runs': 1,
    }
    node_params = {
        'header_size': 1_000,  # bytes
        'max_header_delay': 200,  # ms
        'gc_depth': 50,  # rounds
        'sync_retry_delay': 10_000,  # ms
        'sync_retry_nodes': 3,  # number of nodes
        'batch_size': 500_000,  # bytes
        'max_batch_delay': 200  # ms
    }
    try:
        Bench(ctx).run(bench_params, node_params, debug)
    except BenchError as e:
        Print.error(e)


@task
def plot(ctx):
    ''' Plot performance using the logs generated by "fab remote" '''
    if Ploter is None:
        Print.error('matplotlib is not installed. Please install it: pip install matplotlib')
        return
    plot_params = {
        'faults': [0],
        'nodes': [10, 20, 50],
        'workers': [1],
        'collocate': True,
        'tx_size': 512,
        'max_latency': [3_500, 4_500]
    }
    try:
        Ploter.plot(plot_params)
    except PlotError as e:
        Print.error(BenchError('Failed to plot performance', e))


@task
def kill(ctx):
    ''' Stop execution on all machines (AWS) '''
    try:
        Bench(ctx).kill()
    except BenchError as e:
        Print.error(e)


@task
def logs(ctx):
    ''' Print a summary of the logs '''
    try:
        print(LogParser.process('./logs', faults='?').result())
    except ParseError as e:
        Print.error(BenchError('Failed to parse logs', e))


# CloudLab tasks
@task
def cloudlab_info(ctx):
    ''' Display connect information about all CloudLab nodes '''
    try:
        CloudLabInstanceManager.make().print_info()
    except BenchError as e:
        Print.error(e)


@task
def cloudlab_test(ctx):
    ''' Test SSH connections to all CloudLab nodes '''
    try:
        CloudLabBench(ctx).test_connections()
    except BenchError as e:
        Print.error(e)


@task
def cloudlab_install(ctx):
    ''' Install the codebase on all CloudLab nodes '''
    try:
        CloudLabBench(ctx).install()
    except BenchError as e:
        Print.error(e)


@task
def cloudlab_remote(ctx, debug=False):
    ''' Run benchmarks on CloudLab '''
    bench_params = {
        'faults': 0,
        'nodes': [4],
        'workers': 1,
        'collocate': True,
        'rate': [220000],
        'tx_size': 512,
        'duration': 90,
        'runs': 1,
        # 'trigger_attack': [True], 
    }
    node_params = {
        'header_size': 1_000,  # bytes
        'max_header_delay': 200,  # ms
        'gc_depth': 50,  # rounds
        'sync_retry_delay': 10_000,  # ms
        'sync_retry_nodes': 3,  # number of nodes
        'batch_size': 500_000,  # bytes
        'max_batch_delay': 200  # ms
    }
    try:
        CloudLabBench(ctx).run(bench_params, node_params, debug)
    except BenchError as e:
        Print.error(e)


@task
def cloudlab_status(ctx):
    ''' Check if benchmark processes are running on CloudLab nodes '''
    try:
        CloudLabBench(ctx).status()
    except BenchError as e:
        Print.error(e)

@task
def cloudlab_debug(ctx):
    ''' Debug: Check tmux sessions and capture error messages from CloudLab nodes '''
    try:
        CloudLabBench(ctx).debug_sessions()
    except BenchError as e:
        Print.error(e)


@task
def cloudlab_kill(ctx):
    ''' Stop execution on all CloudLab nodes '''
    try:
        CloudLabBench(ctx).kill()
    except BenchError as e:
        Print.error(e)


@task
def cloudlab_download_primary_logs(ctx, nodes='0,1,2,3'):
    ''' Download primary logs from specified CloudLab nodes (default: 0,1,2,3) '''
    import sys
    import os
    # Add benchmark directory to path
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
    
    from download_logs import download_primary_logs
    
    try:
        # Parse node indices
        node_indices = [int(x.strip()) for x in nodes.split(',')]
        Print.info(f'Downloading primary logs from nodes: {node_indices}')
        success = download_primary_logs('cloudlab_settings.json', node_indices)
        if success:
            Print.info('✓ Successfully downloaded primary logs')
        else:
            Print.error('✗ Failed to download some primary logs')
        return success
    except ValueError as e:
        Print.error(f'Invalid node indices format: {nodes}. Use comma-separated numbers like "0,1,2,3"')
        return False
    except Exception as e:
        Print.error(f'Failed to download primary logs: {e}')
        return False
